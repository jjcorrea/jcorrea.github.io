---
layout: post
title: Architecture oriented development
---

Aproximately 50 years ago, software consisted on a tiny part of the overall technological landscape, in which the hardware (electronic components, circuits, etc) was the most important player.

On the other hand, once software became significantly more important to computational systems, and once it started getting more popular, also being part of major of personal and professional activities ubiquitously, the **size** and **complexity** of those systems urged for better solutions than the existing **abstraction** techniques which remained until the end of the 80s, as abstract data types (ADTs), high level programming languages, and modular decomposition techniques.

Notice **abstraction** as a way to deal with the complexity of problems and systems. As human beings we are regularly rebuilding an existing pattern in a different context, so the abstration essence is to *recognize a pattern*, give it a *name*, define its *usage* and look for consistent ways to *specify* it.

## Technologial evolution

After the first completely electronic general purpose computer (ENIAC) was created at the University of Pensilvania, between 1942 and 1945, until the 60s there was a very limited software production, and the size of them was small at all.

However, little by little, software has become a key technology for handling from the simpler applications to the most complex businesses. The technology industy started being one of the most competitive businesses in the world, and the "Software" component became a prevailing force in terms of **technological innovation**.

Despite the importance of this news technology had at that moment, there were no **tools** supporting software development, and little is known about its **development process**. On the same time, the role of **maintenance** began to stand out.

All this factors contributed to the emmergence of the **software engineering**, term coined in a seminal NATO conference which happened in 1968.

## Software Engineering

The central idea in software engineering is to take advantage of engineering **principles** to produce, with low cost, software which runs **correctly** and **efficiently** on the equipments in which they are installed. So once software started having more space, many **software engineering paradigms** arised. 

## The Software systems nature

What makes a system well architected? Someone could say it is when the system does what the user expects. However a more general quality evaluation requires the identification of the well architected software attributes. There are two important attributes in particular that deserves our attention: **reliability** and **maintainability**.

An appropriate level of **reliability** is essential to a software system, independent of its usage. The reliability is an important attribute of software **quality**, implying that the application will perform its functions as expected.

In this context, **maintainability** has two different aspects

- Need of repair: Implementaion defects which require fixes.
- Need of evolution: New requirements satisfaction


## Software architecture

Given the growth in terms of **size** and **complexity**, the development problems started exceeding the **data structures** and **algorithms**... design the global system structure raises as a new problem, in other words, software development oriented to the architecture.

The architectural software development comprehends structural issues as:

- Project **alternatives**
- **Performance** & **scalability**
- Organization and general **control structure(())
- Communication **protocols**
- Project **components functionality** assignment 

It is important to be able to recognize common used structures, and also understand the existing architectures, what helps the engineers to make better decisions about the project alternatives. 

Software architecture is the study of the global organization of sofware systems, as well as its subsystems & components relationships. It explores **notations**, **tools** and **analysis** techniques and components **reuse**.


## The need of the software architecture role

- Act as an structure which enables attending the system requirements
- Serve as the base for consistency and dependeny analysis
- Support reuse




<br />
To be continued...




